================================================================================
                        ISPSC E-QUEUE SYSTEM
                        THESIS DEFENSE GUIDE
================================================================================

PROJECT OVERVIEW
================================================================================
System Name: ISPSC E-Queue System
Purpose: Digital queue management solution for ISPSC service counters with 
         AI-powered customer support and real-time status tracking.
Technology Stack: PHP 8.x, MySQL/MariaDB, JavaScript (Vanilla), Python 3.x (FastAPI)
Architecture: Client-Server web application with a Python-based Sentiment Analysis microservice

================================================================================
SYSTEM ARCHITECTURE & FLOW
================================================================================

1. THREE-TIER ARCHITECTURE
   ┌─────────────────────────────────────────────────────────────┐
   │                    PRESENTATION LAYER                        │
   │  - User Portal (Ticket Generation & Tracking)                │
   │  - Staff Dashboard (Queue Management)                        │
   │  - Admin Dashboard (System Configuration & Analytics)        │
   │  - Public Display (Live Queue Overview)                      │
   └─────────────────────────────────────────────────────────────┘
                              ↓
   ┌─────────────────────────────────────────────────────────────┐
   │                    APPLICATION LAYER                         │
   │  - Role-Based Access Control (RBAC)                          │
   │  - Queue Logic (Priority & Position Tracking)                │
   │  - Email & UI Notifications                                  │
   │  - AI Chatbot Integration (OpenRouter)                       │
   │  - AJAX Polling for Real-time Updates                        │
   └─────────────────────────────────────────────────────────────┘
                              ↓
   ┌─────────────────────────────────────────────────────────────┐
   │                       DATA LAYER                             │
   │  - MariaDB/MySQL (Relational Database)                       │
   │  - PHP PDO (Secure Data Access)                              │
   │  - Python Sentiment Analysis Microservice                    │
   └─────────────────────────────────────────────────────────────┘

2. USER FLOW
   [Customer Login/Register] → [View Live Queue] → [Select Service]
          ↓
   [Generate Ticket] → [Track Position & Wait] → [Receive Notification]
          ↓
   [Proceed to Counter] → [Service Completion] → [Mandatory Feedback]
          ↓
   [Sentiment Analysis Check] → [Exit/New Ticket Allowed]

3. STAFF WORKFLOW
   [Login] → [Set Counter/Window Status] → [Monitor Service Queue]
      ↓
   [Call Next Ticket] → [Process Transaction] → [Complete Transaction]
      ↓
   [System Notifies Next] → [Repeat/Break Toggle]

4. ADMIN WORKFLOW
   [Login] → [Monitor All Queues] → [Manage Windows & Staff]
      ↓
   [Manage Services] → [Review Sentiment Analytics] → [Manage AI Context]

================================================================================
DATABASE STRUCTURE (queue_schema.sql)
================================================================================

CORE TABLES:
1. users: Authentication, roles (admin, staff, user), and status.
2. tickets: Core queue data (number, service_id, window_id, status, timestamps).
3. services: List of available services (e.g., Registrar, Accounting).
4. windows: Counter/Window configurations and staff assignments.
5. window_services: Mapping services to specific windows.
6. feedback: Customer ratings and sentiment analysis results.
7. ai_context: Knowledge base for the AI chatbot.
8. notifications: System and email notification logs.

RELATIONSHIPS:
- Tickets link to Users (Customer), Services, and Windows.
- Windows are assigned to Staff (Users).
- Feedback is linked directly to a completed Ticket.

================================================================================
KEY FEATURES & IMPLEMENTATION
================================================================================

1. QUEUE MANAGEMENT (models/Ticket.php)
   - Real-time position tracking using current waiting count.
   - Duplicate prevention (one active ticket per user per service).
   - Priority handling based on ticket creation sequence.

2. SENTIMENT ANALYSIS (sentiment_analysis/app.py)
   - Python microservice using FastAPI.
   - Leverages NLP models to categorize feedback as Positive or Negative.
   - Integrated via PHP `curl` calls from the Feedback model.

3. AI CHATBOT (includes/chatbot.php)
   - Integration with OpenRouter API.
   - Uses `ai_context` table to provide project-specific answers.
   - Accessible from the user dashboard for instant support.

4. REAL-TIME DASHBOARDS
   - Vanilla JS AJAX polling to minimize server load while ensuring freshness.
   - Automatic refresh of ticket lists and status indicators.

================================================================================
SECURITY IMPLEMENTATION & DEFENSE
================================================================================

1. CROSS-SITE REQUEST FORGERY (CSRF) PROTECTION
   What is it? 
   CSRF is an attack that tricks a logged-in user into submitting a malicious 
   request (e.g., calling a ticket, changing a password) without their knowledge.
   
   How does this system stop it?
   - Token Generation: When a user logs in, the system generates a unique, 
     random "CSRF Token" and stores it in the user's session.
   - Transmission: This token is embedded in all forms and sent as a header 
     in AJAX requests.
   - Validation: For every state-changing request (POST/PUT/DELETE), the server 
     compares the token sent by the browser with the one in the session.
   - Result: If they don't match, the request is rejected. This ensures 
     that only requests originating from our actual application are processed.

2. SQL INJECTION (SQLi) PREVENTION
   System Measure: use of PHP Data Objects (PDO) with Prepared Statements.
   - Instead of injecting user input directly into SQL queries (e.g., "$id"), 
     we use placeholders (e.g., ":id").
   - The database compiles the SQL logic first, then binds the data separately. 
     This makes it impossible for malicious user input to change the query's logic.

3. CROSS-SITE SCRIPTING (XSS) PROTECTION
   System Measure: Context-aware Output Escaping.
   - All user-generated content (names, comments, notes) is passed through 
     `htmlspecialchars()` before being displayed in the browser.
   - This converts characters like `<` and `>` into their HTML entities, 
     preventing the execution of malicious scripts.

4. PASSWORD SECURITY & HASHING
   System Measure: One-way Hashing with Bcrypt.
   - Passwords are never stored in plain text.
   - We use `password_hash()` with the BCRYPT algorithm, which includes a 
     unique "salt" for every password to protect against rainbow table attacks.

5. ROLE-BASED ACCESS CONTROL (RBAC)
   System Measure: Session-level Privilege Verification.
   - Every protected page or API endpoint checks the user's role in the 
     session (admin vs staff vs user).
   - If a regular user tries to access `/admin`, the system detects the 
     mismatch and redirects them immediately.

================================================================================
COMMON DEFENSE QUESTIONS
================================================================================
Q: Why is feedback mandatory?
A: To ensure data collection for sentiment analysis and service improvement 
   analytics. Users cannot get a new ticket until feedback for the last is provided.

Q: How do you handle real-time updates without WebSockets?
A: We use optimized AJAX polling. It's more compatible with standard shared 
   hosting and sufficient for the scale of a campus queue system.

Q: What is the purpose of the Python microservice?
A: To offload heavy NLP processing (Sentiment Analysis) to a language better 
   suited for AI/ML, keeping the core PHP application fast and lightweight.

Q: Why not just use MD5 for passwords?
A: MD5 is fast and vulnerable to brute-force and rainbow table attacks. 
   Bcrypt is intentionally slower ("work factor") and salted, making it 
   secure against modern cracking techniques.

================================================================================
END OF THESIS DEFENSE GUIDE
================================================================================
